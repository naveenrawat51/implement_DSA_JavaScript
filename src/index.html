<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/themes/prism.min.css" />
    <title>Document</title>
</head>

<body>
    <div id="homeButtonContainer" class="go-to-home">
        <button class="button go-home hide" value="Go To HOME">Go To HOME</button>
    </div>
    <div id="allBtnContainer">
        <div class="buttonContainer">
            <div class="mainHeading">
                <h2 style="text-align: center; color: #4CAF50;">Data Structures</h2>
            </div>
            <button class="button ds-btn" value="ARRAY">ARRAY</button>
            <button class="button ds-btn" value="HASH TABLE">HASH TABLE</button>
            <button class="button ds-btn" value="STACK">STACK</button>
            <button class="button ds-btn" value="QUEUE">QUEUE</button>
            <button class="button ds-btn" value="LINKEDLIST">LINKEDLIST</button>
            <button class="button ds-btn" value="DOUBLY LINKEDLIST">DOUBLY LINKEDLIST</button>
            <button class="button ds-btn" value="BINARY SEARCH TREE">BINARY SEARCH TREE</button>
            <button class="button ds-btn" value="AVL BINARY SEARCH TREE">AVL BINARY SEARCH TREE</button>
            <button class="button ds-btn" value="MIN HEAP">HEAPS</button>
            <button class="button ds-btn" value="GRAPHS">GRAPHS</button>
        </div>

        <div class="buttonContainer">
            <div class="mainHeading">
                <h2 style="text-align: center; color: darkcyan;">Sorting Algorithms</h2>
            </div>
            <button class="button ds-btn srt-btn" value="BUBBLE SORT">BUBBLE SORT</button>
            <button class="button ds-btn srt-btn" value="SELECTION SORT">SELECTION SORT</button>
            <button class="button ds-btn srt-btn" value="INSERTION SORT">INSERTION SORT</button>
            <button class="button ds-btn srt-btn" value="MERGE SORT">MERGE SORT</button>
            <button class="button ds-btn srt-btn" value="QUICK SORT">QUICK SORT</button>
        </div>

        <div class="buttonContainer">
            <div class="mainHeading">
                <h2 style="text-align: center; color: slateblue;">Searching Algorithms</h2>
            </div>
            <button class="button ds-btn srh-btn" value="BFS">BFS(BREADTH FIRST SEARCH)</button>
            <button class="button ds-btn srh-btn" value="DFC">DFS(DEPTH FIRST SEARCH)</button>
            <button class="button ds-btn srh-btn" value="DIJKSTRA">DIJKSTRA</button>
            <button class="button ds-btn srh-btn" value="BELLMAN-FORD">BELLMAN-FORD</button>
            <button class="button ds-btn dp-btn" value="DYNAMIC PROGRAMMING">DYNAMIC PROGRAMMING</button>
        </div>
    </div>

    <div id="complexityContainer" style="text-align: center;" class="hide">
        <table class="table table-bordered table-striped">

            <tbody>
                <tr>
                    <th>Data Structure</th>
                    <th colspan="8">Time Complexity</th>
                    <th>Space Complexity</th>
                </tr>
                <tr>
                    <th></th>
                    <th colspan="4">Average</th>
                    <th colspan="4">Worst</th>
                    <th>Worst</th>
                </tr>
                <tr>
                    <th></th>
                    <th>Access</th>
                    <th>Search</th>
                    <th>Insertion</th>
                    <th>Deletion</th>
                    <th>Access</th>
                    <th>Search</th>
                    <th>Insertion</th>
                    <th>Deletion</th>
                    <th></th>
                </tr>

                <tr id="complexityData">

                </tr>

            </tbody>
        </table>
    </div>
    <div id="sortComplexityContainer" style="text-align: center;" class="hide">
        <table class="table table-bordered table-striped">

            <tbody>
                <tr>
                    <th>Sorting Algorithms</th>
                    <th colspan="3">Time Complexity</th>
                    <th>Space Complexity</th>
                </tr>
                <tr>
                    <th></th>
                    <th colspan="1">Best</th>
                    <th colspan="1">Average</th>
                    <th colspan="1">Worst</th>
                    <th>Worst</th>
                </tr>

                <tr id="sortComplexityData">

                </tr>

            </tbody>
        </table>
    </div>

    <!-- array implementation starts here -->
    <div data-type="ARRAY" class="hide codeSnippet">
        <pre><code class="language-javascript" >
      class Myarray {
        constructor(size) {
            (this.data = {}), (this.length = 0);
    
            for (let i = 0; i &lt; size; i++) {
                this.data[i] = undefined;
                this.length++;
            }
        }
    
        push(item) {
            this.data[this.length] = item;
            this.length += 1;
            return this.data;
        }
    
        pop() {
            if (this.length) {
                delete this.data[this.length - 1];
                this.length -= 1;
                console.log(this.data, this.length);
                return this.data;
            }
            return null;
        }
    
        map(callback) {
            if (typeof callback === 'Function' || typeof callback === 'function') {
                const result = {};
                for (let i = 0; i &lt; this.length; i++) {
                    result[i] = callback(this.data[i], i, this.data);
                }
                return (this.data = result);
            }
            return null;
        }
    
        filter(callback) {
            if (typeof callback === 'Function' || typeof callback === 'function') {
                const result = {};
                let counter = 0;
                for (let i = 0; i &lt; this.length; i++) {
                    if (callback(this.data[i], i, this.data)) {
                        result[counter] = this.data[i];
                        counter++;
                    }
                }
    
                return (this.data = result);
            }
            return [];
        }
    }
    
    const array1 = new Myarray();
    array1.push(5);
    array1.push(23);
    array1.push(3);
    console.log(array1.map((element) => element * 2));
    console.log(array1.filter((element) => element > 10));
  </code>
  </pre>
    </div>
    <!-- array implementation ends here -->

    <!-- stack implementation starts here -->
    <div data-type="STACK" class="hide codeSnippet">
        <pre><code class="language-javascript" >
        class Mystack {
            constructor(){
                this.count = 0;
                this.data = [];
            }
        
            push(item) {
                this.data[this.count] = item;
                this.count += 1;
                return this.data;
            }
        
            pop() {
                if (this.count) {
                    const deletedItem = this.data[this.count -1];
                    this.data.splice(this.count-1, 1);
                    this.count -= 1;
                    return deletedItem;
                }
                return undefined;
            }
        
            peek() {
                return this.data[this.count - 1];
            }
        
            printStack() {
                return this.data;
            }
        
            isEmpty() {
                return this.count === 0;
            }
        }
        
        const stack1 = new Mystack();
        console.log(stack1.push(200));
        console.log(stack1.push(100));
        console.log(stack1.push(500));
        console.log(stack1.pop());
        console.log(stack1.printStack());
        console.log(stack1.peek());
        console.log(stack1.pop());
        console.log(stack1.pop());
        console.log(stack1.peek());
        console.log(stack1.isEmpty());
        
  </code>
  </pre>
    </div>
    <!-- stack implementation ends here -->

    <!-- Linked List implementation starts here -->
    <div data-type="LINKEDLIST" class="hide codeSnippet">
        <pre><code class="language-javascript" >
// new node structure
class Node {
    constructor(value) {
        this.value = value;
        this.next = null;
    }
}

// linkedlist implementation
class LinkedList {
    constructor(value) {
        this.head = {
            value: value,
            next: null
        };
        this.tail = this.head;
        this.length = 1;
    }

    // append at the end O(1)
    append(value) {
        const newNode = new Node(value);
        this.tail.next = newNode;
        this.tail = newNode;
        this.length += 1;

        return this;
    }

    // append at the start O(1)
    prepend(value) {
        const newNode = new Node(value);
        newNode.next = this.head;
        this.head = newNode;
        this.length += 1;

        return this;
    }

    // append at given index O(n)
    appenAt(index, value) {

        if (index &lt; 0 || index > this.length) {
            return;
        }
        const newNode = new Node(value);
        let count = 0;
        let currentNode = this.head;
        let previousNode;

        while(count !== index) {
            previousNode = currentNode;
            currentNode = currentNode.next;
            count++;
        }

        previousNode.next = newNode;
        newNode.next = currentNode;
        this.length += 1;

        return this;
    }

    // remove at given index O(n)
    removeAt(index) {
        if (index &lt; 0 || index > this.length) {
            return;
        }
        let count = 0;
        let currentNode = this.head;
        let previousNode;

        while(count !== index) {
            previousNode = currentNode;
            currentNode = currentNode.next;
            count++;
        }

        previousNode.next = currentNode.next;
        this.length -= 1;

        return this;
    }

    // remove the head O(1)
    removeHead() {
        this.head = this.head.next;
        this.length -= 1;
        return this;
    }

    // remove the tail O(n)
    removeTail() {
        let current = this.head;
        let previous;

        while(current.next) {
            previous = current;
            current = current.next;
        }

        previous.next = null;
        this.tail = previous;
        this.length -= 1;

        return this;

    }

    // search given value O(n)
    search(value) {
        let current = this.head;
        let index = 0;

        while (current.value !== value) {
            current = current.next;
            index += 1;
            if (current == null) {
                return 'item not found';
            }
        }

        return index;
    }

    // Reverse linkedlist
    reverse() {
        if (!this.head.next) {
            return this.head;
        }

        let first = this.head;
        let second = first.next;

        while (second) {
            const temp = second.next;
            second.next = first;
            first = second;
            second = temp;
        }

        this.head.next = null;
        this.head = first;

        return this;
    }

    // print linkedList
    printLinkedList() {
        const result = [];
        let currentNode = this.head;

        while (currentNode) {
            result.push(currentNode.value);
            currentNode = currentNode.next;
        }

        return result;
    }
};

const ll = new LinkedList(100);
console.log(ll.append(500));
ll.prepend(555);
ll.prepend(666);
console.log(ll.prepend(444));
console.log(ll.appenAt(2, 999));
console.log(ll.appenAt(4, 888));
console.log(ll.removeAt(4));
console.log(ll.removeHead());
ll.removeTail();
console.log(ll.search(555))
console.log(ll.printLinkedList());
console.log(ll.reverse());
console.log(ll.printLinkedList());
  </code>
  </pre>
    </div>
    <!-- Linked List implementation ends here -->

    <!-- Doubly Linked List implementation starts here -->
    <div data-type="DOUBLY LINKEDLIST" class="hide codeSnippet">
        <pre><code class="language-javascript" >
        // new node structure
        class Node {
            constructor(value) {
                this.value = value;
                this.next = null;
                this.previous = null;
            }
        }
        
        // linkedlist implementation
        class DoublyLinkedList {
            constructor(value) {
                this.head = {
                    value: value,
                    next: null,
                    previous: null,
                };
                this.tail = this.head;
                this.length = 1;
            }

            // append at the end O(1)
            append(value) {
                const newNode = new Node(value);
                this.tail.next = newNode;
                newNode.previous = this.tail;
                this.tail = newNode;
                this.length += 1;
        
                return this;
            }

            // append at the start O(1)
            prepend(value) {
                const newNode = new Node(value);
                newNode.next = this.head;
                this.head.previous = newNode;
                this.head = newNode;
                this.length += 1;
        
                return this;
            }

            // append at given index O(n)
            appenAt(index, value) {
                if (index &lt; 0 || index > this.length) {
                    return;
                }
                const newNode = new Node(value);
                let count = 0;
                let currentNode = this.head;
                let previousNode;
        
                while (count !== index) {
                    previousNode = currentNode;
                    currentNode = currentNode.next;
                    count++;
                }
        
                previousNode.next = newNode;
                newNode.previous = previousNode;
                newNode.next = currentNode;
                currentNode.previous = newNode;
                this.length += 1;
        
                return this;
            }

            // remove at given index O(n)
            removeAt(index) {
                if (index &lt; 0 || index > this.length) {
                    return;
                }
                let count = 0;
                let currentNode = this.head;
                let previousNode;
        
                while (count !== index) {
                    previousNode = currentNode;
                    currentNode = currentNode.next;
                    count++;
                }
        
                previousNode.next = currentNode.next;
                currentNode.next.previous = previousNode;
                this.length -= 1;
        
                return this;
            }
        
            // remove the head O(1)
            removeHead() {
                this.head.next.previous = null;
                this.head = this.head.next;
                this.length -= 1;
                return this;
            }

            // remove the tail O(n)
            removeTail() {
                let current = this.head;
                let previous;
        
                while (current.next) {
                    previous = current;
                    current = current.next;
                }
        
                previous.next = null;
                this.tail = previous;
                this.length -= 1;
        
                return this;
            }

            // search given value O(n)
            search(value) {
                let current = this.head;
                let index = 0;
        
                while (current.value !== value) {
                    current = current.next;
                    index += 1;
                    if (current == null) {
                        return 'item not found';
                    }
                }
        
                return index;
            }
        }
        
        const ll = new DoublyLinkedList(100);
        console.log(ll.append(500));
        ll.prepend(555);
        ll.prepend(666);
        console.log(ll.prepend(444));
        console.log(ll.appenAt(2, 999));
        console.log(ll.appenAt(4, 888));
        console.log(ll.removeAt(4));
        console.log(ll.removeHead());
        ll.removeTail();
        console.log(ll.search(555));
  </code>
  </pre>
    </div>
    <!-- Doubly Linked List implementation ends here -->

    <!-- Hash Table implementation starts here -->
    <div data-type="HASH TABLE" class="hide codeSnippet">
        <pre><code class="language-javascript" >
        class HashTable {
            constructor(size) {
                this.data = new Array(size);
            }
        
            // hash method
            hashKey(key) {
                let hash = 0;
                for (let i = 0; i &lt; key.length; i++) {
                    hash = (hash + key.charCodeAt(i) * i) % this.data.length;
                }
        
                return hash;
            }
        
            // set a key value in hash table
            set(key, value) {
                const address = this.hashKey(key);
                if (!this.data[address]) {
                    this.data[address] = [];
                }
                this.data[address].push([key, value]);
        
                return this.data;
            }
        
            // get the item from hash table
            get(key) {
                const address = this.hashKey(key);
                const getArray = this.data[address];
        
                if (getArray && getArray.length > 1) {
                    for (let item of getArray) {
                        if (item[0] === key) {
                            return item;
                        }
                    }
                }
        
                return (getArray && getArray[0]) || 'Record not found';
            }
        }
        
        const hash1 = new HashTable(6);
        console.log(hash1.set('naveen', 32));
        console.log(hash1.set('sangeeta', 24));
        console.log(hash1.set('kamal', 24));
        console.log(hash1.set('arya', 24));
        console.log(hash1.set('sanju', 24));
        console.log(hash1.get('naveen'));
        console.log(hash1.get('sangeeta'));
        console.log(hash1.get('sanju'));
        
  </code>
  </pre>
    </div>
    <!-- Hash Table implementation ends here -->


    <!-- Binary Search Tree implementation starts here -->
    <div data-type="BINARY SEARCH TREE" class="hide codeSnippet">
        <pre><code class="language-javascript" >
        class Node {
            constructor(value) {
                this.value = value;
                this.right = null;
                this.left = null;
            }
        }
        
        class BinarySearchTree {
            constructor() {
                this.root = null;
            }
        
            // insert element into BST
            insert(value) {
                const newNode = new Node(value);
        
                if (!this.root) {
                    this.root = newNode;
                } else {
                    let currentNode = this.root;
                    while (true) {
                        if (value &lt; currentNode.value) {
                            if (!currentNode.left) {
                                currentNode.left = newNode;
                                return this;
                            }
                            currentNode = currentNode.left;
                        }
        
                        if (value > currentNode.value) {
                            if (!currentNode.right) {
                                currentNode.right = newNode;
                                return this;
                            }
                            currentNode = currentNode.right;
                        }
                    }
                }
        
                return this;
            }
        
            // look up for node
            lookup(value) {
                if (!this.root) {
                    return false;
                }
        
                let currentNode = this.root;
                while (currentNode) {
                    if (value > currentNode.value) {
                        currentNode = currentNode.right;
                    } else if (value &lt; currentNode.value) {
                        currentNode = currentNode.left;
                    } else if (value === currentNode.value) {
                        return currentNode;
                    }
                }
        
                return false;
            }
        
            // remove node
            remove(value) {
                if (!this.root) {
                    return false;
                }
        
                let currentNode = this.root;
                let parentNode = null;
        
                while (currentNode) {
                    if (value &lt; currentNode.value) {
                        parentNode = currentNode;
                        currentNode = currentNode.left;
                    } else if (value > currentNode.value) {
                        parentNode = currentNode;
                        currentNode = currentNode.right;
                    } else if (value === currentNode.value) {
                        if (!currentNode.right) {
                            if (!parentNode) {
                                this.root = currentNode.left;
                            } else {
                                if (currentNode.value &lt; parentNode.value) {
                                    parentNode.left = currentNode.left;
                                } else if (currentNode.value > parentNode.value) {
                                    parentNode.right = currentNode.left;
                                }
                            }
                        } else if (!currentNode.right.left) {
                            if (!parentNode) {
                                this.root = currentNode.left;
                            } else {
                                currentNode.right.left = currentNode.left;
                                if (currentNode.value &lt; parentNode.value) {
                                    parentNode.left = currentNode.right;
                                } else if (currentNode.value > parentNode.value) {
                                    parentNode.right = currentNode.right;
                                }
                            }
                        } else {
                            let leftMost = currentNode.right.left;
                            let leftMostParent = currentNode.right;
                            while (leftMost.left !== null) {
                                leftMostParent = leftMost;
                                leftMost = leftMost.left;
                            }
        
                            leftMostParent.left = leftMost.right;
                            leftMost.left = currentNode.left;
                            leftMost.right = currentNode.right;
        
                            if (!parentNode) {
                                this.root = leftMost;
                            } else {
                                if (currentNode.value &lt; parentNode.value) {
                                    parentNode.left = leftMost;
                                } else if (currentNode.value > parentNode.value) {
                                    parentNode.right = leftMost;
                                }
                            }
                        }
        
                        return true;
                    }
                }
                return false;
            }
        }
        
        const bst1 = new BinarySearchTree();
        bst1.insert(9);
        bst1.insert(4);
        bst1.insert(6);
        bst1.insert(20);
        bst1.insert(170);
        bst1.insert(15);
        bst1.insert(1);
        bst1.insert(13);
        bst1.insert(17);
        bst1.insert(89);
        bst1.insert(90);
        bst1.insert(220);
        bst1.insert(190);
        console.log(bst1.insert(8));
        console.log(bst1.remove(9));
        //console.log(bst1.lookup(9));
        
  </code>
  </pre>
    </div>
    <!-- Binary Search Tree implementation ends here -->


    <!-- AVL Binary Search Tree implementation starts here -->
    <div data-type="AVL BINARY SEARCH TREE" class="hide codeSnippet">
        <pre><code class="language-javascript" > 
        class Node {
            constructor(value) {
                this.value = value;
                this.right = null;
                this.left = null;
            }
        }
        
        class AvlBinarySearchTree {
            constructor() {
                this.root = null;
                this.Balance = Object.freeze({
                    UNBALANCED_LEFT: 2,
                    SEMIUNBALANCED_LEFT: 1,
                    SEMIUNBALANCED_RIGHT: -1,
                    UNBALANCED_RIGHT: -2,
                    BALANCED: 0,
                });
                this.comparison = Object.freeze({
                    BIGGER: 1,
                    BIGGER_OR_EQUAL: [1, 0],
                    SMALLER: -1,
                    SMALLER_OR_EQUAL: [-1, 0],
                    EQUAL: 0,
                });
            }
        
            compare(a, b) {
                if (a > b) return this.comparison.BIGGER;
                if (a &lt; b) return this.comparison.SMALLER;
        
                return this.comparison.EQUAL;
            }
        
            // insert element into BST
            insert(value) {
                const newNode = new Node(value);
        
                if (!this.root) {
                    this.root = newNode;
                } else {
                    this.root = this.insertNode(newNode);
                }
            }
        
            insertNode(newNode, currentNode = this.root) {
                if (newNode.value &lt; currentNode.value) {
                    currentNode.left = !currentNode.left
                        ? newNode
                        : this.insertNode(newNode, currentNode.left);
                } else {
                    currentNode.right = !currentNode.right
                        ? newNode
                        : this.insertNode(newNode, currentNode.right);
                }
        
                return this.balanceNode(currentNode, newNode.value);
            }
        
            balanceNode(node, value = null) {
                if (node === null) {
                    return node;
                }
        
                const balance = this.getNodeBalanceFactor(node);
                console.log('balance: ' + balance + ' for : ' + node.value);
                if (balance === this.Balance.UNBALANCED_LEFT) {
                    if (value) {
                        node =
                            this.compare(value, node.left.value) ===
                            this.comparison.SMALLER
                                ? this.RRotation(node)
                                : this.LRRotation(node);
                    } else if (node.left) {
                        const leftBalance = this.getNodeBalanceFactor(node.left);
        
                        if (leftBalance === this.Balance.SEMIUNBALANCED_LEFT) {
                            console.log('no key left 1', leftBalance);
                            return this.RRotation(node);
                        }
        
                        if (leftBalance === this.Balance.SEMIUNBALANCED_RIGHT) {
                            console.log('no key left 2', leftBalance);
                            return this.LRRotation(node);
                        }
                    }
                }
        
                if (balance === this.Balance.UNBALANCED_RIGHT) {
                    if (value) {
                        node = this.comparison.BIGGER_OR_EQUAL.includes(
                            this.compare(value, node.right.value)
                        )
                            ? this.LRotation(node)
                            : this.RLRotation(node);
                    } else if (node.right) {
                        const rightBalance = this.getNodeBalanceFactor(node.right);
                        console.log('right', rightBalance);
        
                        if (rightBalance === this.Balance.SEMIUNBALANCED_RIGHT) {
                            console.log('no key right 1', rightBalance);
                            return this.LRotation(node);
                        }
        
                        if (rightBalance === this.Balance.SEMIUNBALANCED_LEFT) {
                            console.log('no key right 2', rightBalance);
                            return this.RLRotation(node);
                        }
                    }
                }
        
                return node;
            }
        
            getNodeBalanceFactor(node) {
                return this.getNodeHeight(node.left) - this.getNodeHeight(node.right);
            }
        
            getNodeHeight(node) {
                if (node === null) {
                    return 0;
                }
        
                return (
                    Math.max(
                        this.getNodeHeight(node.left),
                        this.getNodeHeight(node.right)
                    ) + 1
                );
            }
        
            RRotation(node) {
                const detached = node.left;
                node.left = detached.right;
                detached.right = node;
                return detached;
            }
        
            LRotation(node) {
                const detached = node.right;
                node.right = detached.left;
                detached.left = node;
                return detached;
            }
        
            LRRotation(node) {
                node.left = this.LRotation(node.left);
                return this.RRotation(node);
            }
        
            RLRotation(node) {
                node.right = this.RRotation(node.right);
                return this.LRotation(node);
            }
        
            // look up for node
            lookup(value) {
                if (!this.root) {
                    return false;
                }
        
                let currentNode = this.root;
                while (currentNode) {
                    if (value > currentNode.value) {
                        currentNode = currentNode.right;
                    } else if (value &lt; currentNode.value) {
                        currentNode = currentNode.left;
                    } else if (value === currentNode.value) {
                        return currentNode;
                    }
                }
        
                return false;
            }
        
            // remove node
            remove(value) {
                this.root = this.removeNode(value);
            }
        
            removeNode = (value, node = this.root) => {
                if (node === null) return null;
        
                if (this.compare(value, node.value) === this.comparison.SMALLER) {
                    node.left = this.removeNode(value, node.left);
                    return this.balanceNode(node);
                }
        
                if (this.compare(value, node.value) === this.comparison.BIGGER) {
                    node.right = this.removeNode(value, node.right);
                    return this.balanceNode(node);
                }
        
                // match node is the leaf node
                if (node.left === null && node.right === null) {
                    node = null;
                } else if (node.left === null) {
                    // match node lack left or right node
                    node = node.right;
                } else if (node.right === null) {
                    node = node.left;
                } else {
                    // match node has both of its nodes
                    const max = this.maxNode(node.left);
                    node.value = max.value;
                    node.left = this.removeNode(max.value, node.left);
                }
        
                return this.balanceNode(node, value);
            };
        
            maxNode = (node) => {
                while (node !== null && node.right !== null) {
                    node = node.right;
                }
        
                return node;
            };
        }
        
        const bst1 = new AvlBinarySearchTree();
        bst1.insert(9);
        bst1.insert(4);
        bst1.insert(6);
        bst1.remove(6);
        console.log(bst1.root);
        
  </code>
  </pre>
    </div>
    <!-- AVL Binary Search Tree implementation ends here -->


    <!-- Queue implementation starts here -->
    <div data-type="QUEUE" class="hide codeSnippet">
        <pre><code class="language-javascript" >
        class Node {
            constructor(value) {
                this.value = value;
                this.next = null;
            }
        }
        
        class Queue {
            constructor() {
                this.first = null;
                this.last = null;
                this.length = 0;
            }
        
            peek() {
                return this.first;
            }
        
            enqueue(value) {
                const newNode = new Node(value);
                if (this.length === 0) {
                    this.first = newNode;
                    this.last = newNode;
                } else {
                    this.last.next = newNode;
                    this.last = newNode;
                }
                this.length += 1;
        
                return this;
            }
        
            dequeue() {
                if (!this.first) {
                    return null;
                }
                if (this.first === this.last) {
                    this.last = null;
                    return null;
                }
                this.first = this.first.next;
                this.length -= 1;
        
                return this;
            }
        }
        
        const queue = new Queue();
        queue.enqueue(1);
        queue.enqueue(2);
        queue.enqueue(3);
        queue.enqueue(4);
        console.log(queue.enqueue(5));
        console.log(queue.dequeue());
        console.log(queue.dequeue());
        console.log(queue.peek()); 
  </code>
  </pre>
    </div>
    <!-- Queue implementation ends here -->


    <!-- Min Heap implementation starts here -->
    <div data-type="MIN HEAP" class="hide codeSnippet">
        <pre><code class="language-javascript" >
        class MinHeap {
            constructor() {
                this.heap = [null];
            }
        
            // get min item
            getMin() {
                return this.heap[1];
            }
        
            // insert item
            insert(node) {
                this.heap.push(node);
        
                if (this.heap.length > 1) {
                    let current = this.heap.length - 1;
        
                    while (
                        current > 1 &&
                        this.heap[Math.floor(current / 2)] > this.heap[current]
                    ) {
                        [this.heap[Math.floor(current / 2)], this.heap[current]] = [
                            this.heap[current],
                            this.heap[Math.floor(current / 2)],
                        ];
                        current = Math.floor(current / 2);
                    }
                }
        
                return this.heap;
            }
        
            remove() {
                let smallest = this.heap[1];
        
                if (this.heap.length > 2) {
                    this.heap[1] = this.heap[this.heap.length - 1];
                    this.heap.splice(this.heap.length - 1);
        
                    if (this.heap.length === 3) {
                        if (this.heap[1] > this.heap[2]) {
                            [this.heap[1], this.heap[2]] = [this.heap[2], this.heap[1]];
                        }
                        return smallest;
                    }
        
                    let current = 1;
                    let leftChildIndex = current * 2;
                    let rightChildIndex = current * 2 + 1;
        
                    while (
                        this.heap[leftChildIndex] &&
                        this.heap[rightChildIndex] &&
                        (this.heap[current] > this.heap[leftChildIndex] ||
                            this.heap[current] > this.heap[rightChildIndex])
                    ) {
                        if (this.heap[leftChildIndex] &lt; this.heap[rightChildIndex]) {
                            [this.heap[current], this.heap[leftChildIndex]] = [
                                this.heap[leftChildIndex],
                                this.heap[current],
                            ];
                            current = leftChildIndex;
                        } else {
                            [this.heap[current], this.heap[rightChildIndex]] = [
                                this.heap[rightChildIndex],
                                this.heap[current],
                            ];
                            current = rightChildIndex;
                        }
        
                        leftChildIndex = current * 2;
                        rightChildIndex = current * 2 + 1;
                    }
        
                    if (
                        this.heap[rightChildIndex] === undefined &&
                        this.heap[leftChildIndex] &lt; this.heap[current]
                    ) {
                        [this.heap[current], this.heap[leftChildIndex]] = [
                            this.heap[leftChildIndex],
                            this.heap[current],
                        ];
                    }
                } else if (this.heap.length === 2) {
                    /* If there are only two elements in the array, we directly splice out the first element */
                    this.heap.splice(1, 1);
                } else {
                    return null;
                }
        
                return smallest;
            }
        }
        
        const minHeap = new MinHeap();
        console.log(minHeap.insert(32));
        console.log(minHeap.insert(38));
        console.log(minHeap.insert(45));
        console.log(minHeap.insert(57));
        console.log(minHeap.insert(10));
        console.log(minHeap.insert(23));
        console.log(minHeap.insert(36));
        console.log(minHeap.insert(6));
        minHeap.remove();
        console.log(minHeap.getMin());
        console.log(minHeap.heap);
        
  </code>
  </pre>
    </div>
    <!-- Min Heap implementation ends here -->


    <!-- Graphs implementation starts here -->
    <div data-type="GRAPHS" class="hide codeSnippet">
        <pre><code class="language-javascript" >
        class Graph {
            constructor() {
                this.numberOfNodes = 0;
                this.adjacentList = {}
            };
        
            addVertex(node){
                this.adjacentList[node] = [];
                this.numberOfNodes += 1;
            }
        
            addEdge(node1, node2) {
                 this.adjacentList[node1].push(node2);
                 this.adjacentList[node2].push(node1);
            }
        
            showConnections() {
                const allNodes = Object.keys(this.adjacentList);
                for (let node of allNodes) { 
                    let nodeConnections = this.adjacentList[node]; 
                    let connections = ""; 
                    let vertex;
                    for (vertex of nodeConnections) {
                      connections += vertex + " ";
                    } 
                    console.log(node + "-->" + connections); 
                  }
            }
        }
        
        const myGraph = new Graph();
        myGraph.addVertex('0');
        myGraph.addVertex('1');
        myGraph.addVertex('2');
        myGraph.addVertex('3');
        myGraph.addVertex('4');
        myGraph.addVertex('5');
        myGraph.addVertex('6');
        
        myGraph.addEdge('3', '1');
        myGraph.addEdge('3', '4');
        myGraph.addEdge('4', '2');
        myGraph.addEdge('4', '5');
        myGraph.addEdge('1', '2');
        myGraph.addEdge('1', '0');
        myGraph.addEdge('0', '2');
        myGraph.addEdge('6', '5');
        
        myGraph.showConnections();
        
  </code>
  </pre>
    </div>
    <!-- Graphs implementation ends here -->


    <!-- bubble sort implementation starts here -->
    <div data-type="BUBBLE SORT" class="hide codeSnippet">
        <pre><code class="language-javascript" >
        function bubbleSort(array) {
            const length = array.length;
          
            for (let i = 0; i &lt; length; i++) {
                for (let j = 0; j &lt; length; j++) {
                    if (array[j] > array[j+1]) {
                        const temp = array[j];
                        array[j] = array[j+1];
                        array[j+1] = temp;
                    }
                }
              console.log('after sort: ', array);
            }
        
            return array;
        }
        
        const numbers = [99, 44, 6, 2, 1, 5, 63, 87, 283, 4, 0];
        bubbleSort(numbers);         
  </code>
  </pre>
    </div>
    <!-- bubble sort implementation ends here -->


    <!-- selection sort implementation starts here -->
    <div data-type="SELECTION SORT" class="hide codeSnippet">
        <pre><code class="language-javascript" >
        function selectionSort(array) {
            const length = array.length;
        
            for (let i = 0; i &lt; length; i++) {
                const min = i;
                const temp = array[i];
                for (let j = i + 1; j &lt; length; j++) {
                    if (array[i] > array[j]) {
                       min = j;
                    }
                }
                array[i] = array[min];
                array[min] = temp;
            }
        
            return array;
        }
        
        const numbers = [99, 44, 6, 2, 1, 5, 63, 87, 283, 4, 0];
        selectionSort(numbers);        
  </code>
  </pre>
    </div>
    <!-- selection sort implementation ends here -->


    <!-- insertion sort implementation starts here -->
    <div data-type="INSERTION SORT" class="hide codeSnippet">
        <pre><code class="language-javascript" >
        function insetionSort(array) {
            const length = array.length;
        
            for (let i = 0; i &lt; length; i++) {
                if (array[0] > array[i]) {
                    array.unshift(array.splice(i, 1)[0])
                } else {
                    for (let j = 1; j &lt; i; j++) {
                        if (array[i] &lt; array[j]) {
                            array.splice(j, 0, array.splice(i,1)[0])
                        }
                    }
                }
            }
        
            return array;
        }
        
        const numbers = [99, 44, 6, 2, 1, 5, 63, 87, 283, 4, 0];
        insetionSort(numbers);        
  </code>
  </pre>
    </div>
    <!-- insertion sort implementation ends here -->


    <!-- merge sort implementation starts here -->
    <div data-type="MERGE SORT" class="hide codeSnippet">
        <pre><code class="language-javascript" >
        function mergeSort(array) {
            if (array.length === 1) {
                return array;
            }
        
            const mid = Math.floor(array.length / 2);
            const leftArray = array.slice(0, mid);
            const rightArray = array.slice(mid);
        
            return merge(mergeSort(leftArray), mergeSort(rightArray));
        }
        
        function merge(left, right) {
            const result = [];
            let leftIndex = 0;
            let rightIndex = 0;
        
            while (leftIndex &lt; left.length && rightIndex &lt; right.length) {
                if (left[leftIndex] &lt; right[rightIndex]) {
                    result.push(left[leftIndex]);
                    leftIndex++;
                } else {
                    result.push(right[rightIndex]);
                    rightIndex++;
                }
            }
        
            return result.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));
        }
        
        const numbers = [99, 44, 6, 2, 1, 5, 63, 87, 283, 4, 0];
        console.log(mergeSort(numbers));
          
  </code>
  </pre>
    </div>
    <!-- merge sort implementation ends here -->


    <!-- quick sort implementation starts here -->
    <div data-type="QUICK SORT" class="hide codeSnippet">
        <pre><code class="language-javascript" >
            function quickSort(array, lowerBound, upperBound) {
                if (lowerBound &lt; upperBound) {
                    const partitionIndex = partition(array, lowerBound, upperBound);
            
                    quickSort(array, lowerBound, partitionIndex - 1);
                    quickSort(array, partitionIndex + 1, upperBound);
                }
            
                return array;
            }
            
            function partition(array, lowerBound, upperBound) {
                let pivot = array[lowerBound];
                let start = lowerBound;
                let end = upperBound;
            
                while (start &lt; end) {
                    while (array[start] &lt;= pivot) {
                        start++;
                    }
            
                    while (array[end] > pivot) {
                        end--;
                    }
            
                    if (start &lt; end) {
                        [array[end], array[start]] = [array[start], array[end]];
                    }
                }
            
                [array[lowerBound], array[end]] = [array[end], array[lowerBound]];
            
                return end;
            }
            
            const numbers = [99, 44, 6, 2, 1, 5, 63, 87, 283, 4, 0];
            console.log(quickSort(numbers, 0, 10));      
  </code>
  </pre>
    </div>
    <!-- quick sort implementation ends here -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.5.0/prism.min.js"></script>
</body>

</html>